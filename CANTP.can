/*@!Encoding:1252*/

variables {
  // Frame types and Flow Status
  const byte FRAME_SF = 0x00;  // Single Frame
  const byte FRAME_FF = 0x10;  // First Frame
  const byte FRAME_CF = 0x20;  // Consecutive Frame
  const byte FRAME_FC = 0x30;  // Flow Control Frame
  const byte FC_CTS = 0x00;    // Continue to Send
  const byte FC_WAIT = 0x01;   // Wait
  const byte FC_OVF = 0x02;    // Overflow

  const byte MAX_FC_WAIT = 10; // maximum number of FC.WAIT frames
  const byte SEND_FC_WAIT_TIMEOUT = 10; // maximum number of FC.WAIT frames
  
  // Configuration
  byte BS;                     // Block Size
  byte STMIN;                  // Separation Time (ms)
  byte PADDING = 0xCC;         // Padding value
  byte FS;                     // Flow Status

  // Buffers and state
  byte g_tx_buffer[4095];
  byte g_rx_buffer[4095];
  dword g_tx_length;
  dword g_rx_length;
  dword g_cf_received;
  byte g_seq_num;
  dword g_cf_offset;
  byte g_fc_wait_sent = 0;
  
  // Parameter timers
  msTimer t_STmin;
  msTimer t_sendFCWaitTimer;
}

// Initialize CAN-TP
void cantp_init() {
  g_tx_length = 0;
  g_rx_length = 0;
  
  g_cf_received = 0;
  g_seq_num = 1;
  g_cf_offset = 6;
  g_fc_wait_sent = 0;
  
  cancelTimer(t_STmin);
}

// Send Single Frame
void cantp_send_sf(message *Txmsgx, byte data[], dword length) {
  byte i;
  Txmsgx.dlc = 8;
  Txmsgx.byte(0) = FRAME_SF | (length & 0x0F);
  for (i = 0; i < length; i++) {
    Txmsgx.byte(i + 1) = data[i];
  }
  for (i = length + 1; i < 8; i++) {
    Txmsgx.byte(i) = PADDING;
  } 
  output(Txmsgx);
}

// Send First Frame
void cantp_send_ff(message *Txmsgx, byte data[], dword length) {
  byte i;
  Txmsgx.dlc = 8;
  Txmsgx.byte(0) = FRAME_FF | ((length >> 8) & 0x0F);
  Txmsgx.byte(1) = length & 0xFF;
  for (i = 0; i < 6; i++) {
    Txmsgx.byte(i + 2) = data[i];
  }
  output(Txmsgx);
}

// Send Consecutive Frame
void cantp_send_cf(message *Txmsgx, byte data[], dword offset, byte seq) {
  byte i, len;
  len = (g_tx_length - offset > 7) ? 7 : (g_tx_length - offset);
  Txmsgx.dlc = 8;
  Txmsgx.byte(0) = FRAME_CF | (seq & 0x0F);
  for (i = 0; i < len; i++) {
    Txmsgx.byte(i + 1) = data[offset + i];
  }
  for (i = len + 1; i < 8; i++) {
    Txmsgx.byte(i) = PADDING;
  }
  g_cf_received++;
  output(Txmsgx);
}

// Send Flow Control Frame
void cantp_send_fc(message *Txmsgx, byte fs, byte bs, byte stmin) {
  byte i;
  Txmsgx.dlc = 8;
  Txmsgx.byte(0) = FRAME_FC | (fs & 0x0F);
  Txmsgx.byte(1) = bs;
  Txmsgx.byte(2) = stmin;
  for (i = 3; i < 8; i++) {
    Txmsgx.byte(i) = PADDING;
  };
  output(Txmsgx);
}

void cantp_handle_sf(message *Rxmsgx)
{
  byte i;
  g_rx_length = Rxmsgx.byte(0) & 0x0F;
  for (i = 0; i < g_rx_length; i++) {
    g_rx_buffer[i] = Rxmsgx.byte(i + 1);
  }
  write("Received SF, %d bytes", g_rx_length);
}

void cantp_handle_ff(message *Rxmsgx, message *Txmsgx)
{
  byte i;
  g_rx_length = ((Rxmsgx.byte(0) & 0x0F) << 8) | Rxmsgx.byte(1);
  for (i = 0; i < 6; i++) {
    g_rx_buffer[i] = Rxmsgx.byte(i + 2);
  }
  setTimer(t_sendFCWaitTimer,SEND_FC_WAIT_TIMEOUT);
  cantp_send_fc(Txmsgx, FS, BS, STMIN);
  write("Received FF, total %d bytes", g_rx_length);
}

void cantp_handle_cf(message *Rxmsgx, message *Txmsgx)
{
  dword offset;
  byte seq, i, len;
  
  seq = Rxmsgx.byte(0) & 0x0F;
  if (seq != g_seq_num) {
    write("Invalid sequence number %d, expected %d", seq, g_seq_num);
    cantp_init();
    return;
  } else {
    // Do nothing
  }
  offset = 6 + (seq - 1) * 7;
  len = (g_rx_length - offset > 7) ? 7 : (g_rx_length - offset);
  for (i = 0; i < len; i++) {
    g_rx_buffer[offset + i] = Rxmsgx.byte(i + 1);
  }
  g_seq_num = (g_seq_num + 1) % 16;
  g_cf_received++;
  
  if (offset + len >= g_rx_length) {
    write("Received all CFs, total %d bytes", g_rx_length);
    cantp_init();
  } else if (BS != 0 && g_cf_received >= BS) {
    cantp_send_fc(Txmsgx, FS, BS, STMIN);
    g_cf_received = 0;
  } else {
    // Do nothing
  }
}

void cantp_handle_fc(message *Rxmsgx, message *Txmsgx)
{
  byte fs, bs, stmin;
  
  fs = Rxmsgx.byte(0) & 0x0F;
  bs = Rxmsgx.byte(1);
  stmin = Rxmsgx.byte(2);
  
  if (fs == FC_CTS) {
    if (g_cf_offset < g_tx_length) {
      setTimer(t_STmin, STMIN);
    } else {
      // Do nothing
    }
  } else if (fs == FC_WAIT) {
    write("Receiver requested wait");
  } else if (fs == FC_OVF) {
    write("Receiver overflow");
    cantp_init();
  } else {
    // Do nothing
  }
}

void cantp_handle_received_frame(message *Rxmsgx, message *Txmsgx)
{
  if ((Rxmsgx.byte(0) & 0xF0) == FRAME_SF) {
    cantp_handle_sf(Rxmsgx);
  } else if ((Rxmsgx.byte(0) & 0xF0) == FRAME_FF) {
    cantp_handle_ff(Rxmsgx, Txmsgx);
  } else if ((Rxmsgx.byte(0) & 0xF0) == FRAME_CF) {
    cantp_handle_cf(Rxmsgx, Txmsgx);
  } else if ((Rxmsgx.byte(0) & 0xF0) == FRAME_FC) {
    cantp_handle_fc(Rxmsgx, Txmsgx);
  } else {
    // Do nothing
  }
}

void cantp_handle_send_cf_on_stmin(message *Txmsgx)
{
  if (g_cf_offset < g_tx_length) {
    cantp_send_cf(Txmsgx, g_tx_buffer, g_cf_offset, g_seq_num);
    g_cf_offset += 7;
    g_seq_num = (g_seq_num + 1) % 16;
    
    if (BS != 0 && (g_cf_received >= BS)) {
      g_cf_received = 0;
    } else if (g_cf_offset >= g_tx_length) {
      cantp_init();
    } else {
      setTimer(t_STmin, STMIN);
    }
  } else {
    // Do nothing
  }
}

void cantp_handle_send_message(message *Txmsgx)
{
  byte i;
  
  if (g_tx_length == 0 || g_tx_length > 4095) {
    write("ID 0x%03X: Invalid tx_length (%d)", Txmsgx.id,g_tx_length);
    return;
  } else {
    // Do nothing
  }
 
  for (i = 0; i < g_tx_length; i++) {
    g_tx_buffer[i] = i + 1;
  }
  
  if (g_tx_length <= 7) {
    cantp_send_sf(Txmsgx, g_tx_buffer, g_tx_length);
  } else {
    cantp_send_ff(Txmsgx, g_tx_buffer, g_tx_length);
  }
  write("ID 0x%03X sent %d bytes", g_tx_length);
}
