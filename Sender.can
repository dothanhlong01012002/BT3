/*@!Encoding:1252*/

includes
{
  #include "CANTP.can"
}

variables
{
  message 0x123 MsgID123;
  message 0x456 RxMsg;
}

on start
{
  cantp_init();
  write("ECU1 initialized");
}

on key 's'
{
  byte i;
  if (sender_state != STATE_IDLE) {
    write("ECU1: Sender busy");
    return;
  }
  
  updateVar();
  if (tx_length == 0 || tx_length > 4095) {
    write("ECU1: Invalid tx_length (%d)", tx_length);
    return;
  }
  
  for (i = 0; i < tx_length; i++) {
    tx_buffer[i] = i + 1;
  }
  
  cf_received = 0;
  fc_received = 0;
  cf_offset = 6;
  
  if (tx_length <= 7) {
    sender_state = STATE_SENDING_SF;
    cantp_send_sf(MsgID123, tx_buffer, tx_length);
  } else {
    sender_state = STATE_SENDING_FF;
    cantp_send_ff(MsgID123, tx_buffer, tx_length);
  }
  write("ECU1 sent %d bytes", tx_length);
}

on message 0x456
{
  RxMsg = this;
  
  if ((RxMsg.byte(0) & 0xF0) == FRAME_SF) {
    cantp_handle_sf(RxMsg);
  } else if ((RxMsg.byte(0) & 0xF0) == FRAME_FF) {
    cantp_handle_ff(RxMsg, MsgID123);
  } else if ((RxMsg.byte(0) & 0xF0) == FRAME_CF) {
    cantp_handle_cf(RxMsg, MsgID123);
  } else if ((RxMsg.byte(0) & 0xF0) == FRAME_FC) {
    cantp_handle_fc(RxMsg, MsgID123);
  }
}

on timer t_STmin
{
  if (sender_state == STATE_SENDING_CF && cf_offset < tx_length) {
    cantp_send_cf(MsgID123, tx_buffer, cf_offset, seq_num);
    cf_offset += 7;
    seq_num = (seq_num + 1) % 16;
    
    if (cf_received >= BS || cf_offset >= tx_length) {
      sender_state = STATE_WAITING_FC;
      setTimer(t_NBs, N_BS_TIMEOUT);
      fc_received++;
      cf_received = 0;
    } else {
      setTimer(t_STmin, STMIN);
    }
  }
}

on timer t_NAs
{
  write("ECU1: N_As timeout");
  cantp_init();
}

on timer t_NBs
{
  write("ECU1: N_Bs timeout (no FC received)");
  cantp_init();
}

on timer t_NCr
{
  write("ECU1: N_Cr timeout (no CF received)");
  cantp_init();
}